//============================= TypeScript Notes ==================================
official website to refer for typescript : https://www.typescriptlang.org/

Why to use the typeScript ? 
                        1) because typescript provide the functionality of the type-safety hence we have to use it within the javascript code make the type safety / means giving the data-type to the variables 
                        2) so because of the above feature we can build the our application with the type-safety 
                        3) because it analyze the code as we type thats it in short 
                        4) in typescript the code length will become more means the no of ines will get increased but it is going to be less prone error free code
                        5) typescript is the development tool , because your project still runs on the javascript 
                        6) typescript is the layer on top of the javascript
                        7) it helps to write the less error free code which is more scalable that is easily understandable and maintainable 
                        8) there are few new keywords are there like union , interface , any and more we will se it one by one  

Two major Extensions used : 
                    1) .tsx = typescript code with the jsx 
                    2) .ts = typescript code 


What is typescript Is and What typescript is NOT  : 
What is typescript Is : 
                    i) it does the static type-checking for you (this is the one main job typeScript does) like example : java , goLang 
                    ii) for example : (how it helps to track the errors at the development stage only)

                              suppose I have the one object and in that object one property is  mensioned with string data-type but I am trying to give the new value as the number format using 
                              the javascript then it should throw the error so at the development stage only I can handle the errors in such cases the typescript play very inportant role  

Why to transform the javascript code into the typescript code ?
when to use the typescript in your project ? 
                        1) if your project is small having the 4 to 5 files in it then it does not make any sense to use the javascript
                        2) you have to use the typescript the big projects which are having more files / complex logic / to give safety check for the data type 


Note : 
    1) All the code that we write in the typescript is finally get compiled into the javascript 
    2) it allows the functionality to write the javascript with little bit accurate behaviour so the errors will become less then use the typescript in your peoject 
    3) for the typescript files you have to use the .ts or .tsx extension (we prefer .tsx)



Diagram How it works : 

/*
  TypeScript Compilation Process:

  +---------------------+       +--------------------+       +-------------------+
  |  TypeScript Code    | --->  |  TypeScript        | --->  |  JavaScript Code  |
  |  (source.ts file)   |       |  Compiler (TSC)    |       |  (output.js file) |
  +---------------------+       +--------------------+       +-------------------+
           |                           |                          ^
           |                           |                          |
           v                           v                          |
   Syntax Checking            Type Checking            Transpilation (conversion)
                              (ensuring types match)
*/





//===================================== Ways to Install or setup the typescript in your code ============================================

1) for system wise like (windows / mac) : 
2) for project level (how to setup) : this we will see at the project time 



1) for system wise like (windows) : 

Step 1) install the typescript globally using the below command (in cmd as adminstrator) : 

    command : npm install -g typescript 


Step 2) check the version of the typescript that you have installed 

    command : npx tsc -v


Step 3) Now open the one folder in the vs code and create the one typescript file like intro.ts 
        //add few line of code in it 
        //to execute that code and convert it into the javascript file use the below command

    command : npx tsc fileName.ts 
    example : npx tsc intro.ts

step 4) then you will get the javascript file with same name with ,js extension where all the typescript code is converted into the javascript 







//=========================================== types In TypeScript  ====================================



                        Types
                        â”œâ”€â”€ Primitive Types
                        â”‚   â”œâ”€â”€ number
                        â”‚   â”œâ”€â”€ string
                        â”‚   â”œâ”€â”€ boolean
                        â”‚   â”œâ”€â”€ bigint
                        â”‚   â”œâ”€â”€ symbol
                        â”‚   â””â”€â”€ null & undefined
                        â”œâ”€â”€ Complex Types
                        â”‚   â”œâ”€â”€ object
                        â”‚   â”œâ”€â”€ array
                        â”‚   â”œâ”€â”€ tuple
                        â”‚   â””â”€â”€ function
                        â”œâ”€â”€ Special Types
                        â”‚   â”œâ”€â”€ any
                        â”‚   â”œâ”€â”€ unknown
                        â”‚   â”œâ”€â”€ never
                        â”‚   â””â”€â”€ void
                        â”œâ”€â”€ Union and Intersection Types
                        â”œâ”€â”€ Literal Types
                        â”œâ”€â”€ Enums
                        â””â”€â”€ Custom Types
                            â”œâ”€â”€ Interfaces
                            â””â”€â”€ Type Aliases





//========================== All Types with one example for each ====================================

            // 1. Primitive Types
            // ----------------------

            // a) number
            let num: number = 42; // Any numeric value

            // b) string
            let str: string = "Hello, TypeScript"; // Any string value

            // c) boolean
            let isDone: boolean = true; // Either true or false

            // d) bigint
            let bigInt: bigint = 100n; // Big integers

            // e) symbol
            let sym: symbol = Symbol("unique"); // Unique identifiers

            // f) null & undefined
            let n: null = null; // Represents no value
            let u: undefined = undefined; // Variable not assigned

            // 2. Complex Types
            // ----------------------

            // a) object
            let obj: object = { name: "John", age: 30 }; // Any object

            // b) array
            let arr: number[] = [1, 2, 3]; // Array of numbers

            // c) tuple
            let tuple: [number, string] = [1, "One"]; // Fixed-length array with specified types

            // d) function
            function greet(name: string): string {
            return `Hello, ${name}`;
            }

            // 3. Special Types
            // ----------------------

            // a) any
            let anything: any = "Can be anything"; // Disables type checking

            Note : if you not give the type then by-default it will take any (so avoid this situation) because of the type-inference 

            // b) unknown
            let unknownType: unknown; // Value type is unknown

            // c) never
            function throwError(message: string): never {
            throw new Error(message); // Function never returns
            }

            // d) void
            function logMessage(message: string): void {
            console.log(message); // Function doesn't return a value
            }

            // 4. Union and Intersection Types
            // ----------------------

            // Union
            let id: string | number = 123; // Can be either string or number

            // Intersection
            interface Person {
            name: string;
            }
            interface Employee {
            employeeId: number;
            }
            let employee: Person & Employee = { name: "Alice", employeeId: 101 };

            // 5. Literal Types
            // ----------------------
            let specificString: "hello" = "hello"; // Only "hello" is allowed

            // 6. Enums
            // ----------------------
            enum Direction {
            Up,
            Down,
            Left,
            Right,
            }
            let dir: Direction = Direction.Up; // Enum value

            // 7. Custom Types
            // ----------------------

            // a) Interface
            interface Car {
            make: string;
            model: string;
            }
            let myCar: Car = { make: "Toyota", model: "Corolla" };

            // b) Type Alias
            type Point = {
            x: number;
            y: number;
            };
            let point: Point = { x: 10, y: 20 };




//========================================= Type inference (ability to determine the type of data automatically)  ===========================================



Type inference : 
                in TypeScript refers to the ability of the TypeScript compiler to automatically 
determine the type of a variable, function, or expression based on the value or context in which 
it is used, without explicitly specifying a type. This feature simplifies code by reducing the need 
for explicit type annotations, while still maintaining strong typing.



General Note While writing the typescript take care : 
                                i) do not use any as the type / avoid such cases where any type is getting used 







//================================== any ==========================================

Note : 
       i) when we not define the type to the variable and we pass the any type data in that variable then internally typescript asign the any as the type to that variable because of the type inferance 

When to use it : 
                1) when I want to turn off the type-cheking for that particular variable then I have to assign the any as the type so the typescript will ignore that variable for the type-checking  
       

Example : 

            // a) any
            let anything: any = "Can be anything"; // Disables type checking

            Note : if you not give the type then by-default it will take any (so avoid this situation) because of the type-inference 






============================================= noImplicitAny ==========================================

When to use the noImplicitAny : 
                            1) when you want that not any variable should have the any as the type be-default then at 
                                such usecases it should throw the error of variable is having the any as the 
                                type at compilation time only then I have to use the noImplicitAny.



// ============================================ any VS noImplicitAny ===================================

For More context about any and noImplicitAny refer the below thing : 

/*
| Feature/Aspect       | `any`                              | `noImplicitAny`                   |
|----------------------|------------------------------------|------------------------------------|
| **Definition**       | A type that disables TypeScript's | A TypeScript compiler option that |
|                      | type-checking for a variable.     | enforces explicit typing for      |
|                      | It can represent any type.        | variables and function parameters.|
|----------------------|------------------------------------|------------------------------------|
| **Purpose**          | Used to opt out of type checking  | Used to ensure type safety by     |
|                      | for specific variables or values. | requiring explicit type annotations.|
|----------------------|------------------------------------|------------------------------------|
| **Behavior**         | No compile-time type checking is  | Throws a compile-time error if    |
|                      | applied; all operations are       | a variable or function parameter  |
|                      | allowed.                          | is implicitly assigned the `any`  |
|                      |                                   | type without an explicit type.    |
|----------------------|------------------------------------|------------------------------------|
| **Flexibility**      | Highly flexible, can assign any   | Enforces strict typing, which     |
|                      | value without error.              | reduces flexibility but improves  |
|                      |                                   | code quality and maintainability. |
|----------------------|------------------------------------|------------------------------------|
| **Use Case**         | When type information is          | When strict type checking is      |
|                      | unavailable, or dynamic content   | desired to avoid unintended       |
|                      | is being handled.                 | behaviors and errors in the code. |
|----------------------|------------------------------------|------------------------------------|
| **Impact on Type     | Can lead to runtime errors if     | Improves type safety, reducing    |
| Safety**             | types are incorrectly assumed.    | the chance of runtime errors.     |
|----------------------|------------------------------------|------------------------------------|
| **Performance**      | Faster compilation due to less    | May slightly increase compilation |
|                      | strict checking.                  | time due to strict checking.      |
|----------------------|------------------------------------|------------------------------------|
| **When to Use**      | - Working with legacy JavaScript  | - Writing new TypeScript projects |
|                      |   codebases.                      |   or refactoring existing code.   |
|                      | - Handling third-party libraries  | - Enforcing code quality and      |
|                      |   without type definitions.       |   maintainability.                |
|----------------------|------------------------------------|------------------------------------|
| **When Not to Use**  | - In critical systems where       | - In quick prototypes or small    |
|                      |   type safety is paramount.       |   scripts where strict typing may |
|                      | - When working in a team that     |   be overkill.                    |
|                      |   prioritizes strict type safety. |                                    |
*/





//======================================= Functions in typescript ===========================

Handling the functions in typescript 
                i) In below code I have handled that within the function the parameters that I am reciving that should have which type and the value function is returning that value should have which type 

Code : 
    Named and arrow functions implemented code 


// Learning how to handle the types in the functions for the parameters and also assigning the type for each function return value 
// num:number = this is the type checking for the parameter that below function is reciving 
// (num:number):number =  and this second type cheking re-present the return type for named function 


    function addTwoNumbers(num: number): number {
        return (num + 10);
    }

    let ans = addTwoNumbers(50);

    console.log(ans);



// now writing the one arrow function that will conver the userName to uppercase 

    const getUpper = (userName: string): string => {
        return userName.toLocaleUpperCase();
    }

    let lowerCaseUserName = getUpper("manoj");



//================= How to pass the default parameter valeu in the typescript functions ============


Code : 


//How to pass the default parameter valeu in the typescript functions

    const signUpUser = (userName: string, userEmail: string, isPaid: boolean = false): boolean => {   //!here for isPaid we have given the default value as the false 
        if (userEmail === "abc@gmail.com") {
            return true; // allow the user to login 
        }
        else {
            return false;
        }
    }


    const statusOfUser = signUpUser("Manoj", "abc@gmail.com");  //!see here I have not passed the isPaid value still it is by-default taking because in the function defination only I have mensioned That 

    console.log(statusOfUser);










//==================================== Function returning the more than one type values (How to Handle it) ====================================

Note : handle with the union types 

// Example : 

//I have to handle it with the union type 

const getValue = (name: string): string | number => {
    if (name === "Manoj") {
        return `${name} is learning Typescript`;
    }
    return 100;
}


const ans2 = getValue("Manoj");





// ============================== writing the logging error function on typescript (while working in team how to console.log the errors) =============





// 1) first Approach : 
//this below will be used by one developer at a time to debug the application errors 
const consoleError = (errorMessage: string): void => {
    console.log(errorMessage);

}


// 2) second Approach using never (prefer this approach)
// this below funtion will be used to log the errors while working accoross the team of the around 20 to 40 developers 
// Note :  if any function is not returning the value then I have to use the special types of the typescript that is (never)

const handleError = (errorMessage: string): never => {
    throw new Error(errorMessage);                      //in This way I have to log the errors 
}







//================================= Differant behaviours of the objects in the typescript =========================

Note : we do not perfer the below some part to create the objects in typescript rather first we 
declare the each key type for its corresponding value and then create the object 




// lets Now I am creating the simple user 

const User = {
    name: "Manoj",
    email: "manoj@abc.com",
    isActive: false
}


// creating the one method to create the object which will have the All the properties of the User Object 
const createUser = ({ name: string, isPaid: boolean }) => {

}

//! directlly adding the un-known key will throw the error 

// createUser({ name: "Manoj", isPaid: true, email: "abc@gmail.com" });  //!now here if I will pass the key which is not defined in the function parameter then it will throw the error 


// but if we create the another object then give that in the createUser method it will not throw the error 

let newUser = {
    name: "Manoj",
    isPaid: true,
    email: "abc@gmail.com"   //^this is not mensioned on the function deination still it is getting allowed to add using the same method that is createUser
}

createUser(newUser);     //!now this will not throw the error this is the odd behaviour of the objects in typescript 



// now the example of the function which is returning the object itself 
// in the below function it is taking the prameter in the object format and and also returing the object only that I have explicitlly mensioned it 
// should return the object with the following keys with corresponding value 
// { courseNameFinal: string, courseFeesFinal: number }


const createCourse = ({ courseName: string, courseFees: number }): { courseNameFinal: string, courseFeesFinal: number } => {
    return { courseNameFinal: string, courseFeesFinal: number }
}


createCourse({ courseName: "react-native", courseFees: 1000 });  //calling the function




//================== We use below way to create the objects in the typeScript ========================

Note : there are multiple options to create the type-checking objects in the typescript 

few ways are : 
            1) using the type Aliases 
            2) using the interface



====================================== 1) using the type Aliases  ====================================

Note : 1) means we are creating the data-type using Aliases internally and we want the value that will come to us that should be in that format only 
       2) means using the type we can able to create theour custom data-type in typescript 
        3) we can create the our own any dataType and also give the Aliase like below 
                Example: const myString = string 

Code : 



type User2 = {
    name: string,
    email: string,
    isActive: boolean
}


const createNewUser2 = (user: User2): User2 => {   //here we are accepting the user of the type User2 and also wanted this function should return the object having the same properties as the User 

    return {
        name: user.name,
        email: user.email,
        isActive: user.isActive
    }
}

const newllyCreatedUser2 = createNewUser2({ name: "Manoj", email: "abc@gmail.com", isActive: false });

console.log(newllyCreatedUser2);

export { }









//=============================== 2) using the interface =====================================

// giving the type checking with the interface 

interface User {
    readonly dbId: number,                          //! this data will be read only you cannot modify this 
    name: string,
    userId: number,
    userEmail: string,
    googleId?: string,                               //!optional that each user can have or it cannot have 
    // &below is the way How I can define the method in the interface 
    startTrail: () => string,    //^ this method should return the string hence it in mensioned in the interface its return type checking 

    // lets say for user I want to give the coupon then using the following way I can add method to it 
    // which will take the one parameter that is couponName 

    getCoupon: (couponName: string) => number
}

// now lets create the Newuser of the type User 

const newUser: User = {
    dbId: 10,
    name: "Manoj",
    userId: 1245,
    userEmail: "abc@gmail.com",
    startTrail: () => {
        return "trail is started"
    },
    getCoupon: (couponName: string) => {
        // Any string is accepted for `couponName`
        console.log(`Coupon applied: ${couponName}`);
        // now I want to give the 50 % off 
        return 50;
    }

}

// newUser.dbId = 45;   //^throw the error 


// Example usage
console.log(newUser.getCoupon("React-Native-Course")); // Works with any string
console.log(newUser.getCoupon("JavaScript-Course"));    // Works with any string


console.log(newUser);










//===============================(IMP) Differance between the interface and the type in typescript (How interface use extends and type use & for merging the object type checking with their properties and methods ) ======================

// -----------------------------------------------------------------------
// Difference Between `interface` and `type` in TypeScript
// -----------------------------------------------------------------------

// | **Aspect**             | **interface**                                                                 | **type**                                                                                           |
// |-------------------------|-------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------|
// | **Primary Use**         | Used to define object shapes, methods, and class contracts.                  | Used to define types, including primitives, object shapes, unions, intersections, and aliases.    |
// | **Extending**           | Supports extension with `extends`. An interface can extend other interfaces. | Uses intersection (`&`) for combining types but cannot extend in the same way as `interface`.     |
// | **Reopening / Adding**  | Interfaces allow reopening, letting you add new properties after the initial | Types do not allow reopening; once declared, they cannot be modified.                             |
// | **New Properties**      | declaration.                                                                 |                                                                                                   |
// | **Example**             | ```typescript                                                               | ```typescript                                                                                     |
// |                         | interface A { propA: string; }                                              | type A = { propA: string; };                                                                      |
// |                         | interface A { propB: number; }  // Adds new property                        | type A = { propB: number; }; // Error: Duplicate identifier 'A'                                   |
// |                         | const obj: A = { propA: "hello", propB: 42 };                               |                                                                                                   |
// | **Default Use Case**    | Use for defining object shapes, contracts, and reusable structures (e.g.,    | Use for combining types, creating union types, or defining complex aliases (e.g., primitives).    |
// |                         | API responses).                                                             |                                                                                                   |
// | **Declaration Merging** | **Supported**: Multiple declarations with the same name are merged.          | **Not Supported**: `type` declarations cannot be merged.                                          |
// | **Union Types**         | Not supported. Cannot create unions directly.                                | **Supported**: Can define union types (e.g., `type ID = string | number;`).                       |
// | **Intersection Types**  | Limited: Use `extends` for combining interfaces.                             | **Supported**: Use `&` for intersections (e.g., `type Person = User & Admin;`).                   |
// | **Type Aliases**        | Not applicable.                                                              | Can alias primitives, tuples, and other complex types (e.g., `type Pair = [number, string];`).     |
// | **Object Literals**     | Better readability for object literals and contracts.                        | Flexible but less specific when used for advanced types.                                          |
// | **Performance**         | Slightly more performant for large projects due to its specific use case.    | Slightly slower for very large projects due to broader flexibility.                               |
// | **Default Use Case**    | Preferred for defining object structures and APIs (e.g., classes, props).    | Preferred for unions, intersections, or type aliases for complex scenarios.                       |

// -----------------------------------------------
// Usage Examples
// -----------------------------------------------

// **1. Extending**
// Interface example:
interface User {
    name: string;
    email: string;
}

interface Admin extends User {
    adminRights: string[];
}

// Type example:
type UserType = {
    name: string;
    email: string;
};

type AdminType = UserType & {
    adminRights: string[];
};

// **2. Declaration Merging**
// Interface supports merging:
interface MergedUser {
    name: string;
}

interface MergedUser {
    email: string;
}

// Type does not support merging:
// type MergedType = { name: string };
// type MergedType = { email: string }; // Error

// **3. Union Types**
// Only supported with `type`:
type ID = string | number; // Valid

// **4. Intersection Types**
// Combine types using `&`:
type Address = { city: string };
type Person = UserType & Address;

// **5. Type Aliases**
type Primitive = string;       // Alias for a primitive type
type Pair = [number, string];  // Alias for a tuple




//================================ New Concepts ==========================


// Concepts Covered 
// 1) readonly (keyword)
// 2) ? (literal question mark) (means that property will become optional )
// 3) useCase scenario of above concepts 


//! 1) readonly (keyword)

// when to use it 
//     when we want that particular property that is comming from the backend in any object using that only tables 
// of the databases are designed then that id or unique property should not get changed for such cases we will make that property as the read only 


type User = {
    readonly _id: string,               //!this will be only readable cannot update this value because of the readonly 
    name: string,
    email: string,
    isActive: boolean,
    creditCardDetails?: number          //!now this became optional means it is not compulsory that each User should have the credit card details 
}


// now creating the user with the variable not with the function 

const myUser: User = {
    _id: "123",
    name: "abc",
    email: "abc@gmail.com",
    isActive: true
}

// Now see I can change the all the values of the properties of the object myUser but cannot change the id

myUser.name = "manoj"; //^this I can able to change 

myUser.isActive = false;  //^this I can able to change 


// !but this I cannot able to change because it is readonly 

//myUser._id = "456";   //error : Cannot assign to '_id' because it is a read-only property





//^ Now lets see the how readonly works on the array in typescript 
// !For Array 

type Car = {
    readonly _id: Array<string>; // each element represent =  string (that I have to mension)
    name: string,
    companyName: string,
    isRunning: boolean
}


const Audi: Car = {
    _id: ["1542"],
    name: "Q-7",
    companyName: "Audi",
    isRunning: true
}

//! Note : for the readonly if there is array then we can add the values in 
//! it but we cannot re-assign the new Array to it means readyonly for array 
//! gives the functionality to add the array elements to it but re-assigning the array elements is not allowed 


console.log("before adding the elements : ", Audi._id);


Audi._id.push("45");
Audi._id.push("78");

console.log("Audi._id array after ading elements : ", Audi._id);


//Audi._id = [];    //!this is re-assigning the entire new Array is not allowed 




//! 3) useCase scenario of above concepts 


// lets applying the type checking for the payments data of the user 

type cardNumber = {
    cardNumber: string
}


type cardDate = {
    cardDate: string
}

type cardCvv = {
    cardCvv: string
}
// !(&) this will merge the all the object types into the one object type 

type cardDetails = cardNumber & cardDate & cardCvv;   //this (&) will merge the all the details 

let hdfcCard: cardDetails = {
    cardNumber: "456",
    cardDate: "01/12/2024",
    cardCvv: "08759"
}


console.log("hdfc card details : ", hdfcCard);















// ================================== Union Types in TypeScript (Indetail)==================

Note : Union in typescript allows you to give the multiple types to the any variable or the function using the (|) this symbol 



// Unions gives the functionality to add the more than one type to the variable or the function return type 

let indiaScore: (number | string | boolean) = 500;   //means I can assign the any of the three data types values to this variable 


indiaScore = "450";

indiaScore = true;



// ^ Scenario suppose we will have the one user in the company that is User also and it beomes Admin Also 

type User = {
    name: string,
    id: number
}



type Admin = {
    userName: string,
    id: number
}


// ^Now I wanted to make the user as the myself who will be also the user and also be the admin when it is neccessary 


let Manoj: User | Admin = {
    name: "manoj",
    id: 98,
}

// ^Now also want to make him as the admin 

Manoj = {
    userName: "Admin-Manoj",
    id: 75
}






// Unions with the functions 

const getDbId = (id: string | number): void => {
    if (typeof (id) === "string") {
        console.log("id is in string format");

    }
    else if (typeof (id) === "number") {
        console.log("id is in number format");

    }
}

getDbId("45");
getDbId(154);








//^ ========================= How to declare the Arrays in typescript with the type specific ====================

const ArrayInNumber: number[] = [10, 20, 40, 158];   //only numbers data type is allowed 

const ArrayInString: string[] = ["45", "25", "63", "41"];  //only string data type is allowed 

// ! now array with the mix type of the data in the typescript 

const mixedtypeArray: (number | string)[] = ["Hello", 20, "element", "98"];  //!in this way I can create the mix data type array in the typescript 



export { }











//===================================== tuples in typescript ===================================

Right now actual coding this is skiiped I will come to this once I implement the What I learned in typescript into the shuff 










//====================================================== Interface In typescript ===========================================


// giving the type checking with the interface 

interface User {
    readonly dbId: number,                          //! this data will be read only you cannot modify this 
    name: string,
    userId: number,
    userEmail: string,
    googleId?: string,                               //!optional that each user can have or it cannot have 
    // &below is the way How I can define the method in the interface 
    startTrail: () => string,    //^ this method should return the string hence it in mensioned in the interface its return type checking 

    // lets say for user I want to give the coupon then using the following way I can add method to it 
    // which will take the one parameter that is couponName 

    getCoupon: (couponName: string) => number
}


//!==================================== re-opening of the interface =================================================

// !re-opening of the interface : means adding the more properties and methods to it after its declaration that it 

interface User {
    userLocation: string
}



// now lets create the Newuser of the type User 

const newUser: User = {
    dbId: 10,
    name: "Manoj",
    userId: 1245,
    userEmail: "abc@gmail.com",
    userLocation: "mumbai",
    startTrail: () => {
        return "trail is started"
    },
    getCoupon: (couponName: string) => {
        // Any string is accepted for `couponName`
        console.log(`Coupon applied: ${couponName}`);
        // now I want to give the 50 % off 
        return 50;
    }

}

// newUser.dbId = 45;   //^throw the error 


// Example usage
console.log(newUser.getCoupon("React-Native-Course")); // Works with any string
console.log(newUser.getCoupon("JavaScript-Course"));    // Works with any string


console.log(newUser);




//! ======================================= interface provides the inheritance ==================================
// I want the Admin should have its own properties and also it should have prperties of the user also so I will inherit the all the properties of the User using extends 

interface Admin extends User {  //^here I am inheriting the all user properties of User to Admin 
    adminId: string,

}

// ^ lets assume there is the admin with the name manoj 

const newAdmin: Admin
    = {
    adminId: "7854",
    dbId: 12,
    name: "Rohit",
    userId: 45,
    userEmail: "abd@gmail.com",
    userLocation: "chennai",
    startTrail: () => {
        return "trail is started"
    },
    getCoupon: (couponName: string) => {
        // Any string is accepted for `couponName`
        console.log(`Coupon applied: ${couponName}`);
        // now I want to give the 50 % off 
        return 80;
    }
}


console.log("newAdmin", newAdmin);

newAdmin.getCoupon("node-js");






//================================== Classes in typescript ============================================

class User {
    userName: string
    readonly userEmail: string
    constructor(userName: string, userEmail: string) {
        this.userName = userName;
        this.userEmail = userEmail
    }
}

const manoj = new User("manoj", "abc@gmail.com");

console.log(manoj);

// ^now lets see if I will try to change the value of the userEmail typescript will restrict it from changing

// manoj.userEmail = "asdf@gmail.com";     //error : Cannot assign to 'userEmail' because it is a read-only property.ts(2540)







//========================================== Private / Public / Protected / getters and setters how it works in Typescript =============================================




//! understanding the private and the public and protected how it works in the typescript

/**
*!Note : 
    1) public : 
                if you make any property as the public then it can be accessible within that class and also outside the class 

     
    2)  private : 
                if we make any property as the private then it can be accessible within the that class only but if you try to 
                acess it or change that property value then you have to use the getters and setters for that            


    3) protected :
                if we make any property as the protected then that property will be accesed within the that class and also in the class where that new Class is extending the class which has the one property as the protected , but note outside the class that property anywhere will be not accessible 
 */


// *** Public Example ***
// Public properties can be accessed from within the class and outside the class.
class PublicExample {
    public name: string;

    constructor(name: string) {
        this.name = name;
    }

    public display(): string {
        return `Hello, ${this.name}`;
    }
}

const publicObj = new PublicExample("John");
console.log(publicObj.name); // Accessing public property directly
console.log(publicObj.display()); // Accessing public method


// *** Private Example ***
// Private properties can only be accessed within the class. To access or modify them, you need getters and setters.
class PrivateExample {
    private _age: number;

    constructor(age: number) {
        this._age = age;
    }

    // Getter for the private property
    get getAge(): number {
        return this._age;
    }

    // Setter for the private property
    set setAge(newAge: number) {
        if (newAge > 0) {
            this._age = newAge;
        } else {
            console.log("Age must be a positive number");
        }
    }
}

const privateObj = new PrivateExample(25);
console.log(privateObj.getAge); // Accessing private property via getter
privateObj.setAge = 30; // Modifying private property via setter
console.log(privateObj.getAge); // Accessing modified value
privateObj.setAge = -5; // Trying to set an invalid value


// *** Protected Example ***
// Protected properties can be accessed within the class and in derived (child) classes.
class ProtectedExample {
    protected secret: string;

    constructor(secret: string) {
        this.secret = secret;
    }

    protected revealSecret(): string {
        return `The secret is: ${this.secret}`;
    }
}

class DerivedProtectedExample extends ProtectedExample {
    public showSecret(): string {
        // Accessing protected property and method in a derived class
        return this.revealSecret();
    }
}

const protectedObj = new DerivedProtectedExample("My Secret");
console.log(protectedObj.showSecret()); // Accessing protected property via child class method
// protectedObj.secret; // Error: Property 'secret' is protected and only accessible within class or derived class







//=========================================== Generics in the Typescript ===================================





//! Learning the how generics helps to do the type checking means how it blocks the type once it receive


//^Why to use the generics in the typescript :
/**
    1) Generics in TypeScript are used to create //**reusable, flexible, and type-safe components**, functions,
    and classes. They allow developers to define a component or function
    that can work with multiple types while still enforcing type safety.

    2) if we use the generics while creating the componenets or the functions or classes then the it becomes more type safe means the
        whatever the user will pass the data that type of data will get locked and that type of the data will only get returned

    3) When you use generics, the type of data passed to a function, class, or component gets "locked in" based on the type provided by the user.


    4) This ensures that the same type is used consistently throughout the function or class, preventing type mismatches.

    5) to understand the other developers that the type we have given using the generics for that we use the <T ,> (this represent it is quama)

*/


// ^lets build some re-usable componenets with the generics

// *Scenario 1 

// first lets see the normal way how we were giving the type checking for the functions using the types like number or string or any 
// &below function is like explicit we have difine the type it should take the argument in the number and also return the number data-type 

function identify1(argument: number): number {
    return argument;
}


// *Scenario 2 

// suppose I want that function should take the what the user will send the data of whichever type and it should lock that data-type and same type of data should get returned
// & then I have to go with the generics               

// !Syntax of the using the generics              

function identify2<T,>(argument: T): T {  //*here this function will take the data of the type that user will send and the same type will be locked and then same data of the same type will be returned that is great  
    return argument;
}



// now lets see how to create the array  of the particular type  

const score: Array<number> = [];
const names: Array<string> = [];


// ^now lets create the few more functions to understand the generics in detail how it works and all


//!normal way 

function identityOne(val: boolean | number): boolean | number {
    return val;
}


// !using any (That I should not prefer)

function identityTwo(val: any): any {
    return val;
}

// !now using the generics by the types that will come from theuser that type it will take that will get locked and the same type of the data will get returned over here 
//* it works like any but not exactlly like any means it will take the any type of the data but once one typeof the data is taken then it will lock that type and it will return the same type of data 


function identityThree<T,>(val: T): T {
    return val;
}


let data = identityThree(85);   //*now it will take the number as the type and it will block that type and return the same type 

console.log("data : ", data);

console.log(typeof data);             //*here it will return the same type only 




//!if I want to create the my own Type then using below I can do 

// *Defining the interface
interface Bootle {
    brand: string;
    type: number;
}

// *Generic function using the `Bootle` interface
function identityFour<T extends Bootle>(item: T): T {    //here the whaterver the type will be decided by user that will extends Bootle interface 
    console.log(`Brand: ${item.brand}, Type: ${item.type}`);
    return item;
}

// *Usage
const myBootle = { brand: "Coca-Cola", type: 1 };
identityFour(myBootle); // Logs: Brand: Coca-Cola, Type: 1






//^================================ Generics in Array and Arrow functions in Typescript ============================

//*with names function 

function getSearchProducts<T>(products: T[]): T {  //means it should retrun the one of the element from that array itself 
    // lets suppose I am doing the some databse operation 
    const myIndex = 3;
    return products[myIndex];  //!here I am returning the one of the product from the products Array 
}


//* lets try the same with the arrow functions 

const getMoreSerachProducts = <T>(products: T[]): T => {
    // lets suppose I am doing the some databse operation 
    const myIndex = 5;
    return products[myIndex];  //!here I am returning the one of the product from the products Array 
}















//============================================= Generic Classes in Typescript =====================================





//*==================================== Generic Classes in Typescript ===================================

//first understand the how extends works in generics by taking the exmple of the function 

function newFunction<T, U extends number>(value1: T, value2: U): object {
    return {
        value1,
        value2
    }
}

// calling the above function 
// newFunction(75, "85");  //!this will throw the error because I am extending the number type which not satify the rule of the generics 


let newObject = newFunction(75, 99);

console.log("newObject : ", newObject);



// !Another example using the interface 
// !this will be usefull while designing the complex things 

interface database {
    connection: string,
    userName: string,
    password: string
}



function myFunction<T, U extends database>(value1: T, value2: U): object {
    return {
        value1,
        value2
    }
}


myFunction(45, { connection: "connected", userName: "user1", password: "78541" });









//!now see actual how the generics works on the selling the courses and quizes 

interface Quize {
    name: string,
    type: string
}


interface Course {
    name: string,
    author: string,
    subject: string
}
// ! Example of the generic class 
// ! now creating the class where I am taking the T as the generic 

class Sellable<T> {
    public cart: T[] = []; // Instance property of type T[]

    addToCart(product: T) {
        this.cart.push(product);
    }

    // Instance getter for accessing the cart
    get cartArray() {
        return this.cart;
    }
}

// Example Usage
const sellableInstance = new Sellable<string>();
sellableInstance.addToCart("Product 1");
sellableInstance.addToCart("Product 2");

console.log("cart array: ", sellableInstance.cartArray); // Output: ["Product 1", "Product 2"]




export { }





//=============================== Type Narrowing in typescript ==================================

Concepts Covered Are : 
                    1) typeof type guards
                    2) instanceof narrowing
                    3) Using type predicates
                    4) Discriminated unions
                    5) The never type (Exhaustiveness checking)


==================== Short overview of type narrowing in typescript how it works and why to use it and when to use it ==========================

// ðŸŒŸ What is Type Narrowing in TypeScript?
// Type narrowing is the process of refining a variable's type 
// to a more specific type based on conditions in your code. 
// It ensures safer and more precise operations.

// ðŸ“Œ Example:
function printLength(value: string | number) {
  // ðŸ” Type Guard: Checking the type of `value`
  if (typeof value === "string") {
    // âœ… TypeScript knows `value` is a string here
    console.log(value.length); // Safe to use `length`
  } else {
    // âœ… TypeScript knows `value` is a number here
    console.log(value.toFixed(2)); // Safe to use `toFixed`
  }
}

// ðŸš€ How Type Narrowing Works:
// 1ï¸âƒ£ **Type Guards**: Use `typeof`, `instanceof`, or custom functions 
//     to refine the type.
//     Example: `if (typeof value === "string")`
//
// 2ï¸âƒ£ **Control Flow Analysis**: TypeScript tracks how the type of 
//     a variable changes as the code executes.

// ðŸ”Ž Examples of Type Narrowing:

// 1ï¸âƒ£ Using `typeof`:
function handleInput(input: string | number) {
  if (typeof input === "string") {
    console.log("It's a string:", input.toUpperCase());
  } else {
    console.log("It's a number:", input.toFixed(2));
  }
}

// 2ï¸âƒ£ Using `instanceof`:
class Dog {
  bark() {
    console.log("Woof!");
  }
}
class Cat {
  meow() {
    console.log("Meow!");
  }
}
function makeSound(animal: Dog | Cat) {
  if (animal instanceof Dog) {
    animal.bark(); // âœ… Narrowed to Dog
  } else {
    animal.meow(); // âœ… Narrowed to Cat
  }
}

// 3ï¸âƒ£ Using Custom Type Guard Functions:
type Fish = { swim: () => void };
type Bird = { fly: () => void };

function isFish(pet: Fish | Bird): pet is Fish {
  return (pet as Fish).swim !== undefined;
}

function move(pet: Fish | Bird) {
  if (isFish(pet)) {
    pet.swim(); // âœ… Narrowed to Fish
  } else {
    pet.fly(); // âœ… Narrowed to Bird
  }
}






//=========================== How to implements works on the Interface and also How Abstract class works ============================================= 


skipping this for now continuing with the genrics and how it works and few more concepts then will be coming back to this concepts again and learning it neatlly  





